<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>3D 互動課表</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: '微軟正黑體', Arial, sans-serif; background-color: #87CEEB; } 
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: black; 
            background: rgba(255, 255, 255, 0.7); 
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            backdrop-filter: blur(5px); 
            border: 1px solid rgba(0,0,0,0.1); 
            transition: opacity 0.3s;
            opacity: 0; 
            max-width: 300px;
        }
        #info h2 { margin: 0 0 10px 0; font-size: 18px; color: #192a56; } 
        #info p { margin: 5px 0; font-size: 14px; color: #333; } 
        
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #333; 
            font-size: 12px;
            pointer-events: none;
        }

        /* 讀取動畫 */
        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #192a56; 
            font-size: 24px;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="loading" class="loading">正在建構您的課表城市...</div>

    <div id="info">
        <h2 id="course-name">課程名稱</h2>
        <p><strong>時間:</strong> <span id="course-time"></span></p>
        <p><strong>地點/備註:</strong> <span id="course-note">無</span></p>
    </div>

    <div id="instructions">
        左鍵旋轉 | 右鍵平移 | 滾輪縮放 | 滑鼠懸停查看詳情
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- 1. 資料準備 ---
        
        // 課程方塊顏色
        const courseColors = [
            0x42a5f5, 0x66bb6a, 0xffa726, 0xab47bc, 0xef5350, 0x26c6da, 0x78909c, 0x8d6e63, 0xba68c8, 0xffee58, 0x4dd0e1, 0x9ccc65, 0xff8a65, 0x7986cb 
        ];
        let colorIndex = 0;

        const rawCourses = [
            { day: 1, start: 4, duration: 3, name: "中文能力與邏輯 AB" }, { day: 1, start: 10, duration: 2, name: "英語溝通三級 AI" }, { day: 1, start: 13, duration: 2, name: "實習課" },
            { day: 2, start: 4, duration: 3, name: "初階程式設計 AA" }, { day: 2, start: 9, duration: 3, name: "計算機概論 AA" },
            { day: 3, start: 4, duration: 3, name: "金融科技與洗錢防制" }, { day: 3, start: 7, duration: 2, name: "實習課" }, { day: 3, start: 9, duration: 3, name: "商用微積分" },
            { day: 4, start: 4, duration: 3, name: "會計學原理" }, { day: 4, start: 9, duration: 3, name: "經濟學原理－個體篇" }, { day: 4, start: 13, duration: 1, name: "實習課" },
            { day: 5, start: 3, duration: 2, name: "體育" }, 
        ];

        const colorMap = {};
        const courses = rawCourses.map(course => {
            if (!colorMap[course.name]) {
                colorMap[course.name] = courseColors[colorIndex % courseColors.length];
                colorIndex++; 
            }
            return { ...course, color: colorMap[course.name] };
        });


        // --- 2. Three.js 場景設定 ---
        const scene = new THREE.Scene();
        const skyBlueBgColor = 0x87CEEB; 
        scene.background = new THREE.Color(skyBlueBgColor); 
        scene.fog = new THREE.Fog(skyBlueBgColor, 20, 80); 

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 40); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 5); 

        // 燈光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 3. 建構場景 ---

        // 參數
        const dayWidth = 4;
        const periodHeight = 1.5; 
        const spacing = 0.5;
        const startX = -((5 * dayWidth) + (4 * spacing)) / 2 + (dayWidth/2); 
        const startZ = -10; 

        // 地板網格 (變淡：使用淺灰色)
        const gridHelper = new THREE.GridHelper(60, 60, 0xaaaaaa, 0xcccccc); 
        gridHelper.position.y = -0.1;
        scene.add(gridHelper);

        // 標籤產生器 (使用 Canvas 畫文字貼圖)
        function createLabel(text, x, z, fontSize = 60, color = '#ffffff') {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const geometry = new THREE.PlaneGeometry(dayWidth, dayWidth/2);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0.1, z);
            mesh.rotation.x = -Math.PI / 2;
            scene.add(mesh);
        }

        // 繪製星期標籤
        const days = ["Mon", "Tue", "Wed", "Thu", "Fri"];
        days.forEach((day, index) => {
            const x = startX + index * (dayWidth + spacing);
            createLabel(day, x, startZ - 3, 80, '#192a56'); 
        });

        // 儲存所有課程方塊以便 Raycaster 檢測
        const courseMeshes = [];

        // 建立課程方塊
        courses.forEach(course => {
            const x = startX + (course.day - 1) * (dayWidth + spacing);
            const z = startZ + ((course.start - 1) * periodHeight) + (course.duration * periodHeight / 2);

            const geometry = new THREE.BoxGeometry(dayWidth - 0.4, 2, (periodHeight * course.duration) - 0.4);
            
            // 課程材質 (維持玻璃效果)
            const material = new THREE.MeshPhysicalMaterial({
                color: course.color,
                transparent: true,
                opacity: 0.9,
                transmission: 0.2, // 玻璃質感
                roughness: 0.1,
                metalness: 0.1,
                clearcoat: 1.0,
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(x, 1, z); 
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            mesh.userData = course; 
            
            scene.add(mesh);
            courseMeshes.push(mesh);
            
            // --- 額外：為方塊添加邊緣線條，模擬「格子」效果 (變淡：降低不透明度) ---
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges, 
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2, transparent: true, opacity: 0.3 }) // 不透明度從 0.5 降到 0.3
            );
            
            line.position.copy(mesh.position);
            scene.add(line);
            
            line.userData = course;
            courseMeshes.push(line);
        });

        // 移除讀取動畫
        document.getElementById('loading').style.display = 'none';

        // --- 4. 互動邏輯 (Raycaster) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let intersectedObject = null;
        let originalColor = null;

        const infoDiv = document.getElementById('info');
        const nameEl = document.getElementById('course-name');
        const timeEl = document.getElementById('course-time');

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        window.addEventListener('mousemove', onMouseMove, false);

        // --- 5. 動畫迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            // Raycasting 檢測
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(courseMeshes);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                const courseMesh = object.geometry.type === 'BoxGeometry' ? object : object;

                if (intersectedObject !== courseMesh) {
                    if (intersectedObject) {
                        if (intersectedObject.material.emissive) {
                             intersectedObject.material.emissive.setHex(intersectedObject.currentHex);
                        } else if (intersectedObject.material.color) {
                            intersectedObject.material.color.setHex(0xffffff); 
                        }
                        const actualBlock = intersectedObject.geometry.type === 'BoxGeometry' ? intersectedObject : scene.children.find(c => c.uuid === intersectedObject.parent.uuid && c.geometry.type === 'BoxGeometry');
                        if(actualBlock) actualBlock.scale.set(1, 1, 1);
                        
                    }

                    intersectedObject = courseMesh;
                    const blockToScale = intersectedObject.geometry.type === 'BoxGeometry' ? intersectedObject : scene.children.find(c => c.uuid === intersectedObject.parent.uuid && c.geometry.type === 'BoxGeometry');


                    if (intersectedObject.material.emissive) {
                        intersectedObject.currentHex = intersectedObject.material.emissive.getHex();
                        intersectedObject.material.emissive.setHex(0x555555); 
                    }
                    if(blockToScale) blockToScale.scale.set(1.05, 1.05, 1.05); 

                    const data = intersectedObject.userData;
                    infoDiv.style.opacity = 1;
                    nameEl.textContent = data.name;
                    nameEl.style.color = '#' + data.color.toString(16); 
                    timeEl.textContent = `星期${['','一','二','三','四','五'][data.day]} 第 ${data.start} - ${data.start + data.duration - 1} 節`;
                }
            } else {
                if (intersectedObject) {
                    if (intersectedObject.material.emissive) {
                        intersectedObject.material.emissive.setHex(intersectedObject.currentHex);
                    } else if (intersectedObject.material.color) {
                        intersectedObject.material.color.setHex(0xffffff); 
                    }
                    
                    const blockToScale = intersectedObject.geometry.type === 'BoxGeometry' ? intersectedObject : scene.children.find(c => c.uuid === intersectedObject.parent.uuid && c.geometry.type === 'BoxGeometry');
                    if(blockToScale) blockToScale.scale.set(1, 1, 1);
                    
                    intersectedObject = null;
                    infoDiv.style.opacity = 0;
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // 視窗縮放處理
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
